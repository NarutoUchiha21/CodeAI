"""
File: code_generator.py
Purpose: Generate code with multi-turn synthesis and iterative refinement
Generated by Code Reverse-Engineering System
"""

import logging
from typing import Dict, List, Any, Optional, Set, Tuple
from dataclasses import dataclass
from enum import Enum
import ast
import os
from models import Specification, ImplementationStep
from openai import OpenAI
import json
import time

# Setup logging
logging.basicConfig(level=logging.DEBUG)
logger = logging.getLogger(__name__)

# Initialize OpenAI client
OPENAI_API_KEY = os.environ.get("OPENAI_API_KEY")
openai_client = OpenAI(api_key=OPENAI_API_KEY)

class CodeGenerationState(Enum):
    INITIAL = "initial"
    REFINING = "refining"
    VALIDATING = "validating"
    COMPLETED = "completed"
    FAILED = "failed"

@dataclass
class GenerationContext:
    step: ImplementationStep
    specifications: List[Specification]
    previous_attempts: List[Dict[str, Any]]
    feedback: List[Dict[str, Any]]
    state: CodeGenerationState
    metadata: Dict[str, Any]

class CodeGenerator:
    def __init__(self):
        self.generation_history = []
        self.context_cache = {}
        self.template_cache = {}

    async def generate_code(self, step: ImplementationStep, specifications: List[Specification]) -> Dict[str, Any]:
        """
        Generate code with multi-turn synthesis and iterative refinement.
        
        Args:
            step: ImplementationStep to generate code for.
            specifications: List of Specification objects.
            
        Returns:
            Dictionary with generation results.
        """
        logger.info(f"Starting code generation for step: {step.id}")
        
        # Initialize generation context
        context = GenerationContext(
            step=step,
            specifications=specifications,
            previous_attempts=[],
            feedback=[],
            state=CodeGenerationState.INITIAL,
            metadata={}
        )
        
        try:
            # Initial code generation
            initial_result = await self._generate_initial_code(context)
            context.previous_attempts.append(initial_result)
            
            # Iterative refinement loop
            max_iterations = 3
            current_iteration = 0
            
            while current_iteration < max_iterations:
                # Validate generated code
                validation_result = await self._validate_generated_code(context)
                context.feedback.append(validation_result)
                
                if validation_result['status'] == 'passed':
                    context.state = CodeGenerationState.COMPLETED
                    break
                
                # Refine code based on validation feedback
                refinement_result = await self._refine_generated_code(context)
                context.previous_attempts.append(refinement_result)
                
                current_iteration += 1
            
            if context.state != CodeGenerationState.COMPLETED:
                context.state = CodeGenerationState.FAILED
            
            # Record generation history
            self.generation_history.append({
                'step_id': step.id,
                'context': context,
                'timestamp': time.time()
            })
            
            return {
                'status': context.state.value,
                'code': context.previous_attempts[-1]['code'],
                'iterations': len(context.previous_attempts),
                'feedback': context.feedback,
                'metadata': context.metadata
            }
            
        except Exception as e:
            logger.error(f"Error during code generation: {e}")
            return {
                'status': CodeGenerationState.FAILED.value,
                'error': str(e)
            }

    async def _generate_initial_code(self, context: GenerationContext) -> Dict[str, Any]:
        """Generate initial code based on specifications."""
        try:
            # Prepare prompt for code generation
            prompt = self._prepare_generation_prompt(context)
            
            # Generate code using OpenAI
            response = await openai_client.chat.completions.create(
                model="gpt-4",
                messages=[
                    {"role": "system", "content": "You are an expert code generator."},
                    {"role": "user", "content": prompt}
                ],
                temperature=0.7,
                max_tokens=2000
            )
            
            # Extract and validate generated code
            generated_code = response.choices[0].message.content
            validated_code = self._validate_and_format_code(generated_code)
            
            return {
                'code': validated_code,
                'timestamp': time.time(),
                'metadata': {
                    'model': 'gpt-4',
                    'temperature': 0.7,
                    'prompt_length': len(prompt)
                }
            }
            
        except Exception as e:
            logger.error(f"Error in initial code generation: {e}")
            raise

    async def _validate_generated_code(self, context: GenerationContext) -> Dict[str, Any]:
        """Validate generated code against specifications and requirements."""
        validation_result = {
            'status': 'failed',
            'issues': [],
            'suggestions': []
        }
        
        try:
            # Syntax validation
            syntax_valid = self._validate_syntax(context.previous_attempts[-1]['code'])
            if not syntax_valid:
                validation_result['issues'].append({
                    'type': 'syntax',
                    'message': 'Generated code has syntax errors'
                })
            
            # Specification compliance
            compliance_issues = self._check_specification_compliance(
                context.previous_attempts[-1]['code'],
                context.specifications
            )
            validation_result['issues'].extend(compliance_issues)
            
            # Code quality checks
            quality_issues = self._check_code_quality(context.previous_attempts[-1]['code'])
            validation_result['issues'].extend(quality_issues)
            
            # Generate suggestions for improvement
            if validation_result['issues']:
                validation_result['suggestions'] = self._generate_improvement_suggestions(
                    validation_result['issues']
                )
            else:
                validation_result['status'] = 'passed'
            
            return validation_result
            
        except Exception as e:
            logger.error(f"Error in code validation: {e}")
            validation_result['issues'].append({
                'type': 'error',
                'message': str(e)
            })
            return validation_result

    async def _refine_generated_code(self, context: GenerationContext) -> Dict[str, Any]:
        """Refine generated code based on validation feedback."""
        try:
            # Prepare refinement prompt
            prompt = self._prepare_refinement_prompt(context)
            
            # Generate refined code using OpenAI
            response = await openai_client.chat.completions.create(
                model="gpt-4",
                messages=[
                    {"role": "system", "content": "You are an expert code refiner."},
                    {"role": "user", "content": prompt}
                ],
                temperature=0.5,
                max_tokens=2000
            )
            
            # Extract and validate refined code
            refined_code = response.choices[0].message.content
            validated_code = self._validate_and_format_code(refined_code)
            
            return {
                'code': validated_code,
                'timestamp': time.time(),
                'metadata': {
                    'model': 'gpt-4',
                    'temperature': 0.5,
                    'prompt_length': len(prompt)
                }
            }
            
        except Exception as e:
            logger.error(f"Error in code refinement: {e}")
            raise

    def _prepare_generation_prompt(self, context: GenerationContext) -> str:
        """Prepare prompt for initial code generation."""
        prompt_parts = [
            "Generate code for the following implementation step:",
            f"Step ID: {context.step.id}",
            f"Description: {context.step.description}",
            "\nSpecifications:"
        ]
        
        for spec in context.specifications:
            prompt_parts.append(f"- {spec.name}: {spec.description}")
        
        prompt_parts.append("\nRequirements:")
        prompt_parts.append("1. Follow best practices and design patterns")
        prompt_parts.append("2. Include proper error handling")
        prompt_parts.append("3. Add appropriate comments and documentation")
        prompt_parts.append("4. Ensure code is maintainable and testable")
        
        return "\n".join(prompt_parts)

    def _prepare_refinement_prompt(self, context: GenerationContext) -> str:
        """Prepare prompt for code refinement."""
        prompt_parts = [
            "Refine the following code based on validation feedback:",
            "\nCurrent code:",
            context.previous_attempts[-1]['code'],
            "\nValidation issues:"
        ]
        
        for issue in context.feedback[-1]['issues']:
            prompt_parts.append(f"- {issue['type']}: {issue['message']}")
        
        prompt_parts.append("\nImprovement suggestions:")
        for suggestion in context.feedback[-1]['suggestions']:
            prompt_parts.append(f"- {suggestion}")
        
        return "\n".join(prompt_parts)

    def _validate_and_format_code(self, code: str) -> str:
        """Validate and format generated code."""
        try:
            # Parse code to validate syntax
            ast.parse(code)
            
            # Format code (placeholder for actual formatting)
            # In a real implementation, this would use a code formatter like black or yapf
            
            return code
            
        except SyntaxError as e:
            logger.error(f"Syntax error in generated code: {e}")
            raise

    def _validate_syntax(self, code: str) -> bool:
        """Validate code syntax."""
        try:
            ast.parse(code)
            return True
        except SyntaxError:
            return False

    def _check_specification_compliance(self, code: str, specifications: List[Specification]) -> List[Dict[str, Any]]:
        """Check if code complies with specifications."""
        issues = []
        
        for spec in specifications:
            # Check for required components
            if not self._check_required_components(code, spec):
                issues.append({
                    'type': 'compliance',
                    'message': f"Missing required component: {spec.name}"
                })
            
            # Check for required functionality
            if not self._check_required_functionality(code, spec):
                issues.append({
                    'type': 'compliance',
                    'message': f"Missing required functionality: {spec.name}"
                })
        
        return issues

    def _check_code_quality(self, code: str) -> List[Dict[str, Any]]:
        """Check code quality metrics."""
        issues = []
        
        # Check code complexity
        complexity = self._calculate_code_complexity(code)
        if complexity > 10:  # Threshold for complexity
            issues.append({
                'type': 'quality',
                'message': f"Code complexity ({complexity}) exceeds threshold"
            })
        
        # Check code duplication
        duplication = self._check_code_duplication(code)
        if duplication:
            issues.append({
                'type': 'quality',
                'message': "Code contains duplicated sections"
            })
        
        return issues

    def _generate_improvement_suggestions(self, issues: List[Dict[str, Any]]) -> List[str]:
        """Generate suggestions for improving code based on issues."""
        suggestions = []
        
        for issue in issues:
            if issue['type'] == 'compliance':
                suggestions.append(f"Implement missing {issue['message']}")
            elif issue['type'] == 'quality':
                suggestions.append(f"Improve code quality: {issue['message']}")
            elif issue['type'] == 'syntax':
                suggestions.append(f"Fix syntax errors: {issue['message']}")
        
        return suggestions

    def _calculate_code_complexity(self, code: str) -> int:
        """Calculate code complexity using cyclomatic complexity."""
        try:
            tree = ast.parse(code)
            complexity = 1  # Base complexity
            
            for node in ast.walk(tree):
                if isinstance(node, (ast.If, ast.While, ast.For, ast.Try, ast.ExceptHandler)):
                    complexity += 1
                elif isinstance(node, ast.BoolOp):
                    complexity += len(node.values) - 1
            
            return complexity
        except SyntaxError:
            return float('inf')

    def _check_code_duplication(self, code: str) -> bool:
        """Check for code duplication using simple string matching."""
        # This is a simple implementation and should be replaced with a more sophisticated
        # duplication detection algorithm in a real implementation
        lines = code.split('\n')
        line_counts = {}
        
        for line in lines:
            line = line.strip()
            if line and not line.startswith('#'):
                line_counts[line] = line_counts.get(line, 0) + 1
                if line_counts[line] > 1:
                    return True
        
        return False

    def _check_required_components(self, code: str, spec: Specification) -> bool:
        """Check if code contains required components from specification."""
        try:
            tree = ast.parse(code)
            
            # Check for required classes
            if 'required_classes' in spec.metadata:
                for class_name in spec.metadata['required_classes']:
                    if not any(
                        isinstance(node, ast.ClassDef) and node.name == class_name
                        for node in ast.walk(tree)
                    ):
                        return False
            
            # Check for required functions
            if 'required_functions' in spec.metadata:
                for func_name in spec.metadata['required_functions']:
                    if not any(
                        isinstance(node, ast.FunctionDef) and node.name == func_name
                        for node in ast.walk(tree)
                    ):
                        return False
            
            return True
        except SyntaxError:
            return False

    def _check_required_functionality(self, code: str, spec: Specification) -> bool:
        """Check if code implements required functionality from specification."""
        try:
            tree = ast.parse(code)
            
            # Check for required imports
            if 'required_imports' in spec.metadata:
                imports = set()
                for node in ast.walk(tree):
                    if isinstance(node, ast.Import):
                        imports.update(n.name for n in node.names)
                    elif isinstance(node, ast.ImportFrom):
                        imports.add(node.module)
                
                if not all(imp in imports for imp in spec.metadata['required_imports']):
                    return False
            
            # Check for required method calls
            if 'required_calls' in spec.metadata:
                calls = set()
                for node in ast.walk(tree):
                    if isinstance(node, ast.Call):
                        if isinstance(node.func, ast.Name):
                            calls.add(node.func.id)
                        elif isinstance(node.func, ast.Attribute):
                            calls.add(node.func.attr)
                
                if not all(call in calls for call in spec.metadata['required_calls']):
                    return False
            
            return True
        except SyntaxError:
            return False
