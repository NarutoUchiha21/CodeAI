"""
File: visualizer.py
Purpose: Create visualizations from codebase analysis and knowledge graphs
Generated by Code Reverse-Engineering System
"""

import logging
import json
from typing import Dict, List, Any, Optional
import networkx as nx
import matplotlib
matplotlib.use('Agg')  # Use non-interactive backend
import matplotlib.pyplot as plt
import matplotlib.colors as mcolors
import io
import base64
import plotly.graph_objects as go
import plotly.express as px
from plotly.utils import PlotlyJSONEncoder

# Setup logging
logging.basicConfig(level=logging.DEBUG)
logger = logging.getLogger(__name__)

def create_visualizations(
    analysis_result: Dict[str, Any], 
    knowledge_graph: Dict[str, Any]
) -> Dict[str, Any]:
    """
    Create visualizations from codebase analysis and knowledge graph.
    
    Args:
        analysis_result: Results from code analysis.
        knowledge_graph: Knowledge graph data.
        
    Returns:
        Dictionary with various visualization data.
    """
    logger.info("Creating visualizations from analysis results and knowledge graph")
    
    visualizations = {}
    
    try:
        # 1. Create code distribution visualization
        visualizations['code_distribution'] = create_code_distribution_chart(analysis_result)
        
        # 2. Create dependency network visualization
        visualizations['dependency_network'] = create_dependency_network(knowledge_graph)
        
        # 3. Create complexity metrics visualization
        visualizations['complexity_metrics'] = create_complexity_metrics_chart(analysis_result)
        
        # 4. Create entity type distribution visualization
        visualizations['entity_distribution'] = create_entity_distribution_chart(analysis_result)
        
        # 5. Create community visualization
        visualizations['communities'] = create_community_visualization(knowledge_graph)
        
        # 6. Create centrality visualization
        visualizations['centrality'] = create_centrality_visualization(knowledge_graph)
        
        logger.info(f"Created {len(visualizations)} visualizations")
        
    except Exception as e:
        logger.error(f"Error creating visualizations: {e}")
        # Add error message to visualizations
        visualizations['error'] = f"Error creating some visualizations: {str(e)}"
    
    return visualizations

def create_code_distribution_chart(analysis_result: Dict[str, Any]) -> Dict[str, Any]:
    """
    Create a chart showing code distribution by language.
    
    Args:
        analysis_result: Results from code analysis.
        
    Returns:
        Dictionary with chart data.
    """
    try:
        # Extract language distribution
        languages = analysis_result.get('languages', {})
        
        if not languages:
            return {'error': 'No language data available'}
        
        # Create pie chart using Plotly
        labels = list(languages.keys())
        values = list(languages.values())
        
        fig = px.pie(
            names=labels,
            values=values,
            title='Code Distribution by Language',
            color_discrete_sequence=px.colors.qualitative.Dark24,
            hole=0.4
        )
        
        fig.update_layout(
            template='plotly_dark',
            paper_bgcolor='rgba(0,0,0,0)',
            plot_bgcolor='rgba(0,0,0,0)',
            margin=dict(l=30, r=30, t=50, b=30),
            legend=dict(orientation='h', yanchor='bottom', y=-0.3, xanchor='center', x=0.5)
        )
        
        # Convert to JSON for embedding in HTML
        chart_json = json.dumps(fig.to_dict(), cls=PlotlyJSONEncoder)
        
        return {
            'type': 'plotly',
            'data': chart_json
        }
        
    except Exception as e:
        logger.error(f"Error creating code distribution chart: {e}")
        return {'error': str(e)}

def create_dependency_network(knowledge_graph: Dict[str, Any]) -> Dict[str, Any]:
    """
    Create a network visualization of code dependencies.
    
    Args:
        knowledge_graph: Knowledge graph data.
        
    Returns:
        Dictionary with network visualization data.
    """
    try:
        # Extract graph data
        graph_data = knowledge_graph.get('graph', {})
        nodes = graph_data.get('nodes', [])
        edges = graph_data.get('edges', [])
        
        if not nodes or not edges:
            return {'error': 'No graph data available'}
        
        # Limit nodes if there are too many (for visualization performance)
        node_limit = 100
        if len(nodes) > node_limit:
            # Sort nodes by type importance
            type_priority = {
                'module': 1,
                'class': 2,
                'function': 3,
                'file': 4
            }
            
            sorted_nodes = sorted(
                nodes, 
                key=lambda n: (type_priority.get(n.get('type', 'unknown'), 999), n.get('code_size', 0)),
                reverse=True
            )
            
            nodes = sorted_nodes[:node_limit]
            node_ids = {n['id'] for n in nodes}
            
            # Filter edges to only include selected nodes
            edges = [e for e in edges if e['source'] in node_ids and e['target'] in node_ids]
        
        # Create node categories based on type
        node_types = set(n.get('type', 'unknown') for n in nodes)
        type_colors = {}
        colors = list(mcolors.TABLEAU_COLORS.values())
        
        for i, node_type in enumerate(node_types):
            type_colors[node_type] = colors[i % len(colors)]
        
        # Create network graph with Plotly
        edge_trace = []
        
        # Create edges
        for edge in edges:
            source_node = next((n for n in nodes if n['id'] == edge['source']), None)
            target_node = next((n for n in nodes if n['id'] == edge['target']), None)
            
            if source_node and target_node:
                # Add curved edges for better visualization
                edge_trace.append(
                    go.Scatter(
                        x=[None, source_node.get('x', 0), target_node.get('x', 0), None],
                        y=[None, source_node.get('y', 0), target_node.get('y', 0), None],
                        mode='lines',
                        line=dict(width=1, color='#888'),
                        hoverinfo='none',
                        showlegend=False
                    )
                )
        
        # Create nodes
        node_trace = go.Scatter(
            x=[n.get('x', 0) for n in nodes],
            y=[n.get('y', 0) for n in nodes],
            mode='markers',
            marker=dict(
                size=10,
                color=[type_colors.get(n.get('type', 'unknown'), '#888') for n in nodes],
                line=dict(width=2, color='#fff')
            ),
            text=[f"{n['label']} ({n.get('type', 'unknown')})" for n in nodes],
            hoverinfo='text'
        )
        
        # Create figure
        fig = go.Figure(data=edge_trace + [node_trace])
        
        # Update layout
        fig.update_layout(
            title='Code Dependency Network',
            titlefont=dict(size=16),
            showlegend=False,
            margin=dict(l=20, r=20, t=40, b=20),
            hovermode='closest',
            template='plotly_dark',
            paper_bgcolor='rgba(0,0,0,0)',
            plot_bgcolor='rgba(0,0,0,0)',
            xaxis=dict(showgrid=False, zeroline=False, showticklabels=False),
            yaxis=dict(showgrid=False, zeroline=False, showticklabels=False)
        )
        
        # Convert to JSON for embedding in HTML
        chart_json = json.dumps(fig.to_dict(), cls=PlotlyJSONEncoder)
        
        return {
            'type': 'plotly',
            'data': chart_json
        }
        
    except Exception as e:
        logger.error(f"Error creating dependency network: {e}")
        return {'error': str(e)}

def create_complexity_metrics_chart(analysis_result: Dict[str, Any]) -> Dict[str, Any]:
    """
    Create a chart showing complexity metrics for the codebase.
    
    Args:
        analysis_result: Results from code analysis.
        
    Returns:
        Dictionary with chart data.
    """
    try:
        # Extract complexity metrics
        metrics = analysis_result.get('metrics', {}).get('complexity', {})
        
        if not metrics:
            return {'error': 'No complexity metrics available'}
        
        # Extract cyclomatic complexity data
        cyclomatic = metrics.get('cyclomatic_complexity', {})
        
        if not cyclomatic:
            return {'error': 'No cyclomatic complexity data available'}
        
        # Limit to top 15 entities by complexity
        sorted_entities = sorted(cyclomatic.items(), key=lambda x: x[1], reverse=True)[:15]
        
        # Create bar chart
        entities = [item[0] for item in sorted_entities]
        complexity_values = [item[1] for item in sorted_entities]
        
        fig = go.Figure()
        
        fig.add_trace(go.Bar(
            x=entities,
            y=complexity_values,
            marker_color='rgba(50, 171, 96, 0.7)',
            name='Cyclomatic Complexity'
        ))
        
        # Add coupling data if available
        coupling = metrics.get('coupling', {})
        if coupling:
            coupling_values = [coupling.get(entity, 0) for entity in entities]
            
            fig.add_trace(go.Bar(
                x=entities,
                y=coupling_values,
                marker_color='rgba(219, 64, 82, 0.7)',
                name='Coupling'
            ))
        
        # Update layout
        fig.update_layout(
            title='Code Complexity Metrics',
            xaxis_title='Entity',
            yaxis_title='Complexity Score',
            barmode='group',
            template='plotly_dark',
            paper_bgcolor='rgba(0,0,0,0)',
            plot_bgcolor='rgba(0,0,0,0)',
            margin=dict(l=50, r=30, t=50, b=100),
            xaxis=dict(tickangle=-45)
        )
        
        # Convert to JSON for embedding in HTML
        chart_json = json.dumps(fig.to_dict(), cls=PlotlyJSONEncoder)
        
        return {
            'type': 'plotly',
            'data': chart_json
        }
        
    except Exception as e:
        logger.error(f"Error creating complexity metrics chart: {e}")
        return {'error': str(e)}

def create_entity_distribution_chart(analysis_result: Dict[str, Any]) -> Dict[str, Any]:
    """
    Create a chart showing the distribution of entity types in the codebase.
    
    Args:
        analysis_result: Results from code analysis.
        
    Returns:
        Dictionary with chart data.
    """
    try:
        # Extract entities
        entities = analysis_result.get('entities', [])
        
        if not entities:
            return {'error': 'No entity data available'}
        
        # Count entity types
        entity_types = {}
        for entity in entities:
            entity_type = entity.get('type', 'unknown')
            entity_types[entity_type] = entity_types.get(entity_type, 0) + 1
        
        # Create bar chart
        types = list(entity_types.keys())
        counts = list(entity_types.values())
        
        fig = px.bar(
            x=types,
            y=counts,
            title='Entity Type Distribution',
            labels={'x': 'Entity Type', 'y': 'Count'},
            color=types,
            color_discrete_sequence=px.colors.qualitative.Bold
        )
        
        # Update layout
        fig.update_layout(
            template='plotly_dark',
            paper_bgcolor='rgba(0,0,0,0)',
            plot_bgcolor='rgba(0,0,0,0)',
            margin=dict(l=50, r=30, t=50, b=50),
            xaxis=dict(categoryorder='total descending')
        )
        
        # Add data labels
        fig.update_traces(texttemplate='%{y}', textposition='outside')
        
        # Convert to JSON for embedding in HTML
        chart_json = json.dumps(fig.to_dict(), cls=PlotlyJSONEncoder)
        
        return {
            'type': 'plotly',
            'data': chart_json
        }
        
    except Exception as e:
        logger.error(f"Error creating entity distribution chart: {e}")
        return {'error': str(e)}

def create_community_visualization(knowledge_graph: Dict[str, Any]) -> Dict[str, Any]:
    """
    Create a visualization of communities in the codebase.
    
    Args:
        knowledge_graph: Knowledge graph data.
        
    Returns:
        Dictionary with visualization data.
    """
    try:
        # Extract communities
        communities = knowledge_graph.get('communities', [])
        
        if not communities:
            return {'error': 'No community data available'}
        
        # Calculate community sizes
        community_sizes = [community.get('size', 0) for community in communities]
        community_ids = [f"Community {community.get('id', i)}" for i, community in enumerate(communities)]
        
        # Create treemap for communities
        community_data = []
        colors = px.colors.qualitative.Dark24
        
        for i, community in enumerate(communities):
            # Get community details
            community_id = community.get('id', i)
            size = community.get('size', 0)
            color_idx = i % len(colors)
            
            # Add primary community entry
            community_data.append({
                "id": f"Community {community_id}",
                "parent": "",
                "value": size,
                "color": colors[color_idx]
            })
            
            # Add member types
            for type_name, type_count in community.get('types', {}).items():
                community_data.append({
                    "id": f"Community {community_id} - {type_name}",
                    "parent": f"Community {community_id}",
                    "value": type_count,
                    "color": colors[(color_idx + 1) % len(colors)]
                })
        
        # Create figure
        fig = go.Figure(go.Treemap(
            ids=[item["id"] for item in community_data],
            parents=[item["parent"] for item in community_data],
            values=[item["value"] for item in community_data],
            marker=dict(
                colors=[item["color"] for item in community_data],
                line=dict(width=2, color='#fff')
            ),
            textinfo="label+value",
            hoverinfo="label+value+percent parent"
        ))
        
        # Update layout
        fig.update_layout(
            title='Code Communities',
            template='plotly_dark',
            paper_bgcolor='rgba(0,0,0,0)',
            plot_bgcolor='rgba(0,0,0,0)',
            margin=dict(l=20, r=20, t=40, b=20),
        )
        
        # Convert to JSON for embedding in HTML
        chart_json = json.dumps(fig.to_dict(), cls=PlotlyJSONEncoder)
        
        return {
            'type': 'plotly',
            'data': chart_json
        }
        
    except Exception as e:
        logger.error(f"Error creating community visualization: {e}")
        return {'error': str(e)}

def create_centrality_visualization(knowledge_graph: Dict[str, Any]) -> Dict[str, Any]:
    """
    Create a visualization of entity centrality in the codebase.
    
    Args:
        knowledge_graph: Knowledge graph data.
        
    Returns:
        Dictionary with visualization data.
    """
    try:
        # Extract centrality metrics
        metrics = knowledge_graph.get('metrics', {}).get('centrality', {})
        
        if not metrics:
            return {'error': 'No centrality metrics available'}
        
        # Get in-degree centrality (entities that are heavily depended upon)
        in_degree = metrics.get('in_degree', {})
        
        if not in_degree:
            return {'error': 'No in-degree centrality data available'}
        
        # Prepare data for radar chart
        entities = list(in_degree.keys())[:7]  # Limit to top 7 for readability
        
        # Get values for each centrality measure
        in_degree_values = [in_degree.get(entity, 0) for entity in entities]
        out_degree_values = [metrics.get('out_degree', {}).get(entity, 0) for entity in entities]
        betweenness_values = [metrics.get('betweenness', {}).get(entity, 0) for entity in entities]
        
        # Create radar chart
        fig = go.Figure()
        
        fig.add_trace(go.Scatterpolar(
            r=in_degree_values,
            theta=entities,
            fill='toself',
            name='In-Degree (Depended Upon)',
            line=dict(color='rgb(99, 110, 250)')
        ))
        
        fig.add_trace(go.Scatterpolar(
            r=out_degree_values,
            theta=entities,
            fill='toself',
            name='Out-Degree (Dependencies)',
            line=dict(color='rgb(239, 85, 59)')
        ))
        
        fig.add_trace(go.Scatterpolar(
            r=betweenness_values,
            theta=entities,
            fill='toself',
            name='Betweenness (Connector)',
            line=dict(color='rgb(0, 204, 150)')
        ))
        
        # Update layout
        fig.update_layout(
            title='Entity Centrality Metrics',
            polar=dict(
                radialaxis=dict(
                    visible=True,
                    range=[0, max(max(in_degree_values), max(out_degree_values), max(betweenness_values))]
                )
            ),
            template='plotly_dark',
            paper_bgcolor='rgba(0,0,0,0)',
            plot_bgcolor='rgba(0,0,0,0)',
            margin=dict(l=30, r=30, t=50, b=30),
            legend=dict(orientation='h', yanchor='bottom', y=-0.2, xanchor='center', x=0.5)
        )
        
        # Convert to JSON for embedding in HTML
        chart_json = json.dumps(fig.to_dict(), cls=PlotlyJSONEncoder)
        
        return {
            'type': 'plotly',
            'data': chart_json
        }
        
    except Exception as e:
        logger.error(f"Error creating centrality visualization: {e}")
        return {'error': str(e)}

def create_file_tree_visualization(analysis_result: Dict[str, Any]) -> Dict[str, Any]:
    """
    Create a visualization of the file structure.
    
    Args:
        analysis_result: Results from code analysis.
        
    Returns:
        Dictionary with visualization data.
    """
    try:
        # Extract structure
        structure = analysis_result.get('structure', {})
        
        if not structure:
            return {'error': 'No structure data available'}
        
        # Extract directories and files
        directories = structure.get('directories', [])
        files = structure.get('files', [])
        
        if not directories and not files:
            return {'error': 'No file structure data available'}
        
        # Create tree data
        tree_data = [{"id": "root", "parent": "", "name": "Root"}]
        
        # Add directories
        for directory in sorted(directories):
            # Split path into parts
            parts = directory.split('/')
            current_path = ""
            
            # Add each part of the path as a node
            for i, part in enumerate(parts):
                parent_path = current_path
                current_path = current_path + "/" + part if current_path else part
                
                # Check if this node already exists
                if not any(item["id"] == current_path for item in tree_data):
                    tree_data.append({
                        "id": current_path,
                        "parent": parent_path if parent_path else "root",
                        "name": part
                    })
        
        # Add files
        for file in sorted(files):
            # Get directory and filename
            last_slash = file.rfind('/')
            if last_slash == -1:
                # File is in the root directory
                parent = "root"
                filename = file
            else:
                # File is in a subdirectory
                parent = file[:last_slash]
                filename = file[last_slash+1:]
            
            tree_data.append({
                "id": file,
                "parent": parent,
                "name": filename
            })
        
        # Create figure
        fig = go.Figure(go.Treemap(
            ids=[item["id"] for item in tree_data],
            parents=[item["parent"] for item in tree_data],
            labels=[item["name"] for item in tree_data],
            texttemplate="%{label}",
            marker=dict(
                colors=[
                    'rgba(200, 200, 200, 0.8)' if item["id"] == "root" else
                    'rgba(55, 126, 184, 0.7)' if item["id"] in directories or '/' not in item["id"] else
                    'rgba(77, 175, 74, 0.7)'
                    for item in tree_data
                ],
                line=dict(width=1, color='#fff')
            ),
            hoverinfo="label+text",
            hovertext=[
                "Root" if item["id"] == "root" else
                "Directory" if item["id"] in directories or '/' not in item["id"] else
                "File"
                for item in tree_data
            ]
        ))
        
        # Update layout
        fig.update_layout(
            title='File Structure',
            template='plotly_dark',
            paper_bgcolor='rgba(0,0,0,0)',
            plot_bgcolor='rgba(0,0,0,0)',
            margin=dict(l=20, r=20, t=40, b=20),
        )
        
        # Convert to JSON for embedding in HTML
        chart_json = json.dumps(fig.to_dict(), cls=PlotlyJSONEncoder)
        
        return {
            'type': 'plotly',
            'data': chart_json
        }
        
    except Exception as e:
        logger.error(f"Error creating file tree visualization: {e}")
        return {'error': str(e)}
