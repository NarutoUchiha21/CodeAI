/**
 * File: visualizations.js
 * Purpose: Handle visualization rendering for the Code Reverse-Engineering System
 * Generated by Code Reverse-Engineering System
 */

/**
 * Loads and renders Plotly visualizations
 * @param {string} containerId - The ID of the container element
 * @param {Object} plotData - The Plotly visualization data
 */
function loadPlotlyVisualization(containerId, plotData) {
    try {
        const container = document.getElementById(containerId);
        if (!container) {
            console.error(`Container element ${containerId} not found`);
            return;
        }
        
        Plotly.newPlot(containerId, plotData.data, plotData.layout || {}, {
            responsive: true,
            displayModeBar: true,
            displaylogo: false
        });
    } catch (error) {
        console.error(`Error loading visualization for ${containerId}:`, error);
        
        // Show error in the container
        const container = document.getElementById(containerId);
        if (container) {
            container.innerHTML = `
                <div class="alert alert-danger">
                    <i class="fas fa-exclamation-triangle me-2"></i>
                    Error loading visualization: ${error.message}
                </div>
            `;
        }
    }
}

/**
 * Loads and renders a network graph visualization
 * @param {string} containerId - The ID of the container element
 * @param {Object} graphData - The graph data with nodes and edges
 */
function loadNetworkGraph(containerId, graphData) {
    try {
        const container = document.getElementById(containerId);
        if (!container) {
            console.error(`Container element ${containerId} not found`);
            return;
        }
        
        // Prepare nodes and edges for visualization
        const nodes = graphData.nodes.map(node => {
            return {
                id: node.id,
                label: node.label || node.id,
                shape: getNodeShape(node.type),
                color: getNodeColor(node.type),
                title: `${node.label || node.id} (${node.type})`
            };
        });
        
        const edges = graphData.edges.map(edge => {
            return {
                from: edge.source,
                to: edge.target,
                arrows: 'to',
                title: edge.relationship || 'connects to'
            };
        });
        
        // Create network
        const data = {
            nodes: new vis.DataSet(nodes),
            edges: new vis.DataSet(edges)
        };
        
        const options = {
            physics: {
                stabilization: true,
                barnesHut: {
                    gravitationalConstant: -2000,
                    centralGravity: 0.3,
                    springLength: 95,
                    springConstant: 0.04,
                    damping: 0.09
                }
            },
            layout: {
                improvedLayout: true
            }
        };
        
        new vis.Network(container, data, options);
    } catch (error) {
        console.error(`Error loading network graph for ${containerId}:`, error);
        
        // Show error in the container
        const container = document.getElementById(containerId);
        if (container) {
            container.innerHTML = `
                <div class="alert alert-danger">
                    <i class="fas fa-exclamation-triangle me-2"></i>
                    Error loading network graph: ${error.message}
                </div>
            `;
        }
    }
}

/**
 * Gets the shape for a node based on its type
 * @param {string} type - The node type
 * @returns {string} The node shape
 */
function getNodeShape(type) {
    const shapeMap = {
        'module': 'box',
        'class': 'ellipse',
        'function': 'diamond',
        'file': 'triangle',
        'component': 'hexagon'
    };
    
    return shapeMap[type] || 'dot';
}

/**
 * Gets the color for a node based on its type
 * @param {string} type - The node type
 * @returns {Object} The node color configuration
 */
function getNodeColor(type) {
    const colorMap = {
        'module': '#4e73df',
        'class': '#1cc88a',
        'function': '#f6c23e',
        'file': '#36b9cc',
        'component': '#e74a3b'
    };
    
    return {
        background: colorMap[type] || '#858796',
        border: '#2c3e50',
        highlight: {
            background: colorMap[type] ? lightenColor(colorMap[type], 20) : '#6e707e',
            border: '#2c3e50'
        }
    };
}

/**
 * Lightens a color by the given percentage
 * @param {string} hex - The hex color code
 * @param {number} percent - The percentage to lighten (0-100)
 * @returns {string} The lightened color as a hex code
 */
function lightenColor(hex, percent) {
    // Convert hex to RGB
    let r = parseInt(hex.substring(1, 3), 16);
    let g = parseInt(hex.substring(3, 5), 16);
    let b = parseInt(hex.substring(5, 7), 16);
    
    // Lighten
    r = Math.min(255, Math.round(r + (255 - r) * (percent / 100)));
    g = Math.min(255, Math.round(g + (255 - g) * (percent / 100)));
    b = Math.min(255, Math.round(b + (255 - b) * (percent / 100)));
    
    // Convert back to hex
    return `#${(r << 16 | g << 8 | b).toString(16).padStart(6, '0')}`;
}