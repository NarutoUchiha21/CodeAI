"""
File: models.py
Purpose: Define data models for code analysis and implementation
Generated by Code Reverse-Engineering System
"""

from typing import Dict, List, Any, Optional, Set
from dataclasses import dataclass
from enum import Enum
import json
import os
from datetime import datetime

class SpecificationType(Enum):
    PROJECT_STRUCTURE = "project_structure"
    DEPENDENCIES = "dependencies"
    CORE_COMPONENT = "core_component"
    FEATURE = "feature"
    INTEGRATION = "integration"
    TEST = "test"
    OPTIMIZATION = "optimization"

class EntityType(Enum):
    MODULE = "module"
    CLASS = "class"
    FUNCTION = "function"
    VARIABLE = "variable"
    CONSTANT = "constant"
    INTERFACE = "interface"
    TYPE = "type"

@dataclass
class CodeEntity:
    """Represents a code entity (module, class, function, etc.)."""
    name: str
    type: EntityType
    path: str
    code: str
    metadata: Dict[str, Any]
    dependencies: List[str]
    complexity: float
    documentation: Optional[str] = None

@dataclass
class Specification:
    """Represents a specification for code implementation."""
    id: str
    name: str
    type: SpecificationType
    description: str
    requirements: List[str]
    constraints: List[str]
    dependencies: List[str]
    metadata: Dict[str, Any]
    priority: int
    estimated_time: int
    created_at: datetime
    updated_at: datetime

@dataclass
class ImplementationStep:
    """Represents a step in the implementation process."""
    id: str
    type: str
    description: str
    specifications: List[Specification]
    dependencies: List[str]
    estimated_time: int
    priority: int
    status: str = "pending"
    progress: float = 0.0
    metadata: Dict[str, Any] = None

@dataclass
class ImplementationStrategy:
    """Represents a strategy for implementing code."""
    steps: List[ImplementationStep]
    dependencies: List[Dict[str, Any]]
    metadata: Dict[str, Any]
    created_at: datetime = datetime.now()
    updated_at: datetime = datetime.now()

@dataclass
class CodebaseAnalysis:
    """Represents the analysis of a codebase."""
    entities: List[CodeEntity]
    dependencies: Dict[str, List[str]]
    metrics: Dict[str, Any]
    patterns: List[Dict[str, Any]]
    metadata: Dict[str, Any]
    created_at: datetime = datetime.now()
    updated_at: datetime = datetime.now()

@dataclass
class ValidationResult:
    """Represents the result of code validation."""
    status: str
    issues: List[Dict[str, Any]]
    suggestions: List[str]
    metrics: Dict[str, Any]
    timestamp: datetime = datetime.now()

@dataclass
class GenerationResult:
    """Represents the result of code generation."""
    code: str
    status: str
    iterations: int
    feedback: List[ValidationResult]
    metadata: Dict[str, Any]
    timestamp: datetime = datetime.now()

@dataclass
class RefinementResult:
    """Represents the result of code refinement."""
    code: str
    improvements: List[Dict[str, Any]]
    metrics: Dict[str, Any]
    timestamp: datetime = datetime.now()

@dataclass
class AgentMessage:
    """Represents a message between agents."""
    role: str
    content: Dict[str, Any]
    timestamp: datetime
    message_id: str
    parent_message_id: Optional[str] = None
    metadata: Dict[str, Any] = None

@dataclass
class AgentState:
    """Represents the state of an agent."""
    role: str
    context: Dict[str, Any]
    memory: List[AgentMessage]
    feedback_loop: List[Dict[str, Any]]
    validation_results: List[ValidationResult]

@dataclass
class SemanticRelation:
    """Represents a semantic relationship between code entities."""
    source: str
    target: str
    relation_type: str
    context: Dict[str, Any]
    confidence: float

@dataclass
class CodePattern:
    """Represents a detected code pattern."""
    type: str
    name: str
    confidence: float
    location: Dict[str, Any]
    context: Dict[str, Any]
    impact: Dict[str, Any]

@dataclass
class StepDependency:
    """Represents a dependency between implementation steps."""
    source: str
    target: str
    type: str
    strength: float
    context: Dict[str, Any]

@dataclass
class GenerationContext:
    """Represents the context for code generation."""
    step: ImplementationStep
    specifications: List[Specification]
    previous_attempts: List[Dict[str, Any]]
    feedback: List[Dict[str, Any]]
    state: str
    metadata: Dict[str, Any]

def load_specifications(file_path: str) -> List[Specification]:
    """Load specifications from a JSON file."""
    try:
        with open(file_path, 'r') as f:
            data = json.load(f)
            return [Specification(**spec) for spec in data]
    except Exception as e:
        print(f"Error loading specifications: {e}")
        return []

def save_specifications(specifications: List[Specification], file_path: str):
    """Save specifications to a JSON file."""
    try:
        data = [vars(spec) for spec in specifications]
        with open(file_path, 'w') as f:
            json.dump(data, f, indent=2, default=str)
    except Exception as e:
        print(f"Error saving specifications: {e}")

def load_implementation_strategy(file_path: str) -> ImplementationStrategy:
    """Load implementation strategy from a JSON file."""
    try:
        with open(file_path, 'r') as f:
            data = json.load(f)
            return ImplementationStrategy(**data)
    except Exception as e:
        print(f"Error loading implementation strategy: {e}")
        return None

def save_implementation_strategy(strategy: ImplementationStrategy, file_path: str):
    """Save implementation strategy to a JSON file."""
    try:
        data = vars(strategy)
        with open(file_path, 'w') as f:
            json.dump(data, f, indent=2, default=str)
    except Exception as e:
        print(f"Error saving implementation strategy: {e}")

def load_codebase_analysis(file_path: str) -> CodebaseAnalysis:
    """Load codebase analysis from a JSON file."""
    try:
        with open(file_path, 'r') as f:
            data = json.load(f)
            return CodebaseAnalysis(**data)
    except Exception as e:
        print(f"Error loading codebase analysis: {e}")
        return None

def save_codebase_analysis(analysis: CodebaseAnalysis, file_path: str):
    """Save codebase analysis to a JSON file."""
    try:
        data = vars(analysis)
        with open(file_path, 'w') as f:
            json.dump(data, f, indent=2, default=str)
    except Exception as e:
        print(f"Error saving codebase analysis: {e}")
