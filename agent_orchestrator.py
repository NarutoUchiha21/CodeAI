"""
File: agent_orchestrator.py
Purpose: Orchestrates AI agents for code re-implementation
Generated by Code Reverse-Engineering System
"""

import logging
from typing import Dict, List, Any, Tuple
import os
import json
import uuid
import re
from models import Specification, ImplementationStrategy, ImplementationStep
from openai import OpenAI
import time

# Setup logging
logging.basicConfig(level=logging.DEBUG)
logger = logging.getLogger(__name__)

# Initialize OpenAI client
OPENAI_API_KEY = os.environ.get("OPENAI_API_KEY")
openai_client = OpenAI(api_key=OPENAI_API_KEY)

# Roles for agent system
AGENT_ROLES = {
    "architect": "Designs high-level architecture and system structure",
    "translator": "Translates specifications into implementation details",
    "programmer": "Writes code based on specifications and architecture",
    "reviewer": "Reviews code for correctness and adherence to specifications",
    "refiner": "Refines code based on review feedback"
}

def orchestrate_agents(specifications: List[Specification], strategy: ImplementationStrategy) -> Dict[str, Any]:
    """
    Orchestrate AI agents to implement code based on specifications and strategy.
    
    Args:
        specifications: List of Specification objects describing the components.
        strategy: ImplementationStrategy with implementation steps.
        
    Returns:
        Dictionary with implementation results.
    """
    logger.info("Starting agent orchestration for implementation")
    
    # Initialize conversation history for tracking agent interactions
    conversation_history = []
    
    # Initialize implementation results
    implementation_result = {
        'specifications': specifications,
        'implementation_details': {
            'architecture': {},
            'components': {},
            'code_snippets': [],
            'execution': {}
        },
        'file_structure': [],
        'agent_interactions': []
    }
    
    # Step 1: Architect designs the system structure
    architecture_design = architect_agent(specifications, strategy, conversation_history)
    implementation_result['implementation_details']['architecture'] = architecture_design
    implementation_result['file_structure'] = architecture_design['file_structure']
    
    # Step 2: Process each implementation step according to the strategy
    execution_order = strategy.execution_order
    all_steps = {step.id: step for step in strategy.steps}
    
    for step_id in execution_order:
        step = all_steps[step_id]
        logger.info(f"Processing implementation step: {step.description}")
        
        # Get relevant specifications for this step
        step_specs = extract_specifications_for_step(step, specifications)
        
        # Generate implementation details for the step
        step_implementation = generate_step_implementation(
            step, 
            step_specs, 
            implementation_result, 
            conversation_history
        )
        
        # Update implementation result with step details
        for file_snippet in step_implementation['code_snippets']:
            implementation_result['implementation_details']['code_snippets'].append(file_snippet)
        
        for component_id, component_details in step_implementation['components'].items():
            implementation_result['implementation_details']['components'][component_id] = component_details
        
        # Record agent interactions
        implementation_result['agent_interactions'].extend(step_implementation['agent_interactions'])
    
    # Step 3: Generate execution instructions
    execution_details = generate_execution_details(implementation_result, conversation_history)
    implementation_result['implementation_details']['execution'] = execution_details
    
    logger.info("Agent orchestration complete")
    
    return implementation_result

def architect_agent(
    specifications: List[Specification], 
    strategy: ImplementationStrategy,
    conversation_history: List[Dict[str, Any]]
) -> Dict[str, Any]:
    """
    Use the architect agent to design system structure.
    
    Args:
        specifications: List of Specification objects.
        strategy: ImplementationStrategy object.
        conversation_history: List to track agent interactions.
        
    Returns:
        Dictionary with architecture design details.
    """
    logger.info("Architect agent: Designing system structure")
    
    # Extract architectural specifications if any
    arch_specs = [spec for spec in specifications if spec.entity_type == 'architecture' or spec.entity_type == 'module']
    
    # Prepare specs for prompt
    specs_json = []
    for spec in specifications:
        spec_dict = {
            "entity_name": spec.entity_name,
            "entity_type": spec.entity_type,
            "purpose": spec.purpose,
            "dependencies": spec.dependencies
        }
        specs_json.append(spec_dict)
    
    # Create system prompt for the architect agent
    system_prompt = f"""
    You are an expert software architect. Your task is to design the structure of a system based on specifications.
    
    Your responsibilities:
    1. Design the overall architecture of the system
    2. Define the file structure
    3. Identify key interfaces between components
    4. Specify design patterns to be used
    5. Consider implementation strategy steps in your design
    """
    
    # Create user prompt with specifications and strategy
    user_prompt = f"""
    I need a detailed architecture design for a system with the following specifications:
    
    ```json
    {json.dumps(specs_json, indent=2)}
    ```
    
    The implementation strategy consists of these steps:
    
    {chr(10).join([f"- {step.description}" for step in strategy.steps])}
    
    Please provide:
    1. A comprehensive architecture design
    2. A file structure listing all required files
    3. Component interfaces and relationships
    4. Appropriate design patterns
    5. Implementation guidelines
    
    Respond with JSON format containing:
    - architecture_style: Overall architecture style/pattern
    - description: Detailed description of the architecture
    - components: List of key components and their responsibilities
    - interfaces: Key interfaces between components
    - design_patterns: Design patterns to be used
    - file_structure: List of files with paths and purposes
    - implementation_guidelines: Guidelines for implementation
    """
    
    # Record the interaction
    conversation_history.append({
        "agent": "architect",
        "role": "system",
        "content": system_prompt
    })
    
    conversation_history.append({
        "agent": "architect",
        "role": "user",
        "content": user_prompt
    })
    
    # Send request to OpenAI
    try:
        # the newest OpenAI model is "gpt-4o" which was released May 13, 2024.
        # do not change this unless explicitly requested by the user
        response = openai_client.chat.completions.create(
            model="gpt-4o",
            messages=[
                {"role": "system", "content": system_prompt},
                {"role": "user", "content": user_prompt}
            ],
            temperature=0.2,
            response_format={"type": "json_object"},
        )
        
        architecture_design = json.loads(response.choices[0].message.content)
        
        # Record the response
        conversation_history.append({
            "agent": "architect",
            "role": "assistant",
            "content": response.choices[0].message.content
        })
        
        return architecture_design
        
    except Exception as e:
        logger.error(f"Error in architect agent: {str(e)}")
        
        # Create fallback architecture design
        fallback_design = {
            "architecture_style": "Simple modular architecture",
            "description": "Fallback architecture due to error in generation",
            "components": [{"name": spec.entity_name, "responsibility": spec.purpose} for spec in specifications[:5]],
            "interfaces": [],
            "design_patterns": [],
            "file_structure": [{"path": f"{spec.entity_name.lower()}.py", "purpose": spec.purpose, "entities": [spec.entity_name]} for spec in specifications],
            "implementation_guidelines": ["Implement each component separately", "Focus on core functionality first"]
        }
        
        # Record the error
        conversation_history.append({
            "agent": "architect",
            "role": "error",
            "content": str(e)
        })
        
        return fallback_design

def extract_specifications_for_step(
    step: ImplementationStep, 
    specifications: List[Specification]
) -> List[Specification]:
    """
    Extract specifications relevant to a specific implementation step.
    
    Args:
        step: ImplementationStep object.
        specifications: List of all Specification objects.
        
    Returns:
        List of Specification objects relevant to the step.
    """
    # Extract entity name and type from step ID if possible
    step_id_parts = step.id.split('_')
    
    if len(step_id_parts) < 2:
        # If we can't extract from ID, return all specs (conservative)
        return specifications
    
    entity_type = step_id_parts[0]
    
    if entity_type == "setup" or entity_type == "arch":
        # For setup and architecture steps, include architecture and module specs
        return [spec for spec in specifications 
                if spec.entity_type in ['architecture', 'module', 'pattern']]
    
    # For entity-specific steps, try to extract entity name from step ID
    # The entity name could contain underscores, so join appropriate parts
    if len(step_id_parts) >= 3:
        entity_name_parts = step_id_parts[1:-1]  # Last part is a UUID
        entity_name = '_'.join(entity_name_parts)
        
        # Find matching specifications
        matching_specs = [spec for spec in specifications 
                         if spec.entity_name == entity_name and spec.entity_type == entity_type]
        
        if matching_specs:
            # Also include dependencies
            dependency_names = []
            for spec in matching_specs:
                if spec.dependencies:
                    dependency_names.extend(spec.dependencies)
            
            # Add dependency specifications
            dependency_specs = [spec for spec in specifications 
                               if spec.entity_name in dependency_names]
            
            return matching_specs + dependency_specs
    
    # If no matches found, use specifications of the same entity type
    type_specs = [spec for spec in specifications if spec.entity_type == entity_type]
    if type_specs:
        return type_specs
    
    # Fallback to all specifications
    return specifications

def generate_step_implementation(
    step: ImplementationStep,
    step_specs: List[Specification],
    implementation_result: Dict[str, Any],
    conversation_history: List[Dict[str, Any]]
) -> Dict[str, Any]:
    """
    Generate implementation details for a specific step using multiple agents.
    
    Args:
        step: ImplementationStep object.
        step_specs: List of Specification objects for this step.
        implementation_result: Current implementation results.
        conversation_history: List to track agent interactions.
        
    Returns:
        Dictionary with implementation details for the step.
    """
    logger.info(f"Generating implementation for step: {step.description}")
    
    # Initialize step implementation details
    step_implementation = {
        'components': {},
        'code_snippets': [],
        'agent_interactions': []
    }
    
    # Step 1: Translator agent converts specifications to implementation details
    translation_result = translator_agent(step, step_specs, implementation_result, conversation_history)
    step_implementation['components'].update(translation_result['components'])
    step_implementation['agent_interactions'].extend(translation_result['agent_interactions'])
    
    # Step 2: Programmer agent generates code
    programming_result = programmer_agent(
        step, 
        step_specs, 
        translation_result, 
        implementation_result, 
        conversation_history
    )
    step_implementation['code_snippets'].extend(programming_result['code_snippets'])
    step_implementation['agent_interactions'].extend(programming_result['agent_interactions'])
    
    # Step 3: Reviewer agent checks the code
    review_result = reviewer_agent(
        step, 
        step_specs, 
        programming_result, 
        implementation_result, 
        conversation_history
    )
    step_implementation['agent_interactions'].extend(review_result['agent_interactions'])
    
    # Step 4: If issues found, refiner agent improves the code
    if review_result['issues']:
        refinement_result = refiner_agent(
            step, 
            step_specs, 
            programming_result, 
            review_result, 
            implementation_result, 
            conversation_history
        )
        
        # Update code snippets with refined versions
        step_implementation['code_snippets'] = refinement_result['code_snippets']
        step_implementation['agent_interactions'].extend(refinement_result['agent_interactions'])
    else:
        # No issues found, use the original code
        step_implementation['code_snippets'] = programming_result['code_snippets']
    
    return step_implementation

def translator_agent(
    step: ImplementationStep,
    step_specs: List[Specification],
    implementation_result: Dict[str, Any],
    conversation_history: List[Dict[str, Any]]
) -> Dict[str, Any]:
    """
    Use the translator agent to convert specifications to implementation details.
    
    Args:
        step: ImplementationStep object.
        step_specs: List of Specification objects for this step.
        implementation_result: Current implementation results.
        conversation_history: List to track agent interactions.
        
    Returns:
        Dictionary with translation results.
    """
    logger.info("Translator agent: Converting specifications to implementation details")
    
    # Prepare specs for prompt
    specs_json = []
    for spec in step_specs:
        spec_dict = {
            "entity_name": spec.entity_name,
            "entity_type": spec.entity_type,
            "purpose": spec.purpose,
            "inputs": spec.inputs,
            "outputs": spec.outputs,
            "constraints": spec.constraints,
            "dependencies": spec.dependencies,
            "behavior": spec.behavior[:500] if spec.behavior else None  # Limit length
        }
        specs_json.append(spec_dict)
    
    # Get architecture design from implementation result
    architecture = implementation_result['implementation_details']['architecture']
    
    # Create system prompt for the translator agent
    system_prompt = f"""
    You are an expert software translator. Your task is to translate high-level specifications into 
    detailed implementation plans.
    
    Your responsibilities:
    1. Understand the specifications and implementation step
    2. Translate specifications into concrete implementation details
    3. Define interfaces, data structures, and algorithms
    4. Ensure alignment with the overall architecture
    5. Provide clear guidelines for the programmer
    """
    
    # Create user prompt with specifications and architecture
    user_prompt = f"""
    I need to translate these specifications into implementation details for the following step:
    
    Step: {step.description}
    
    Specifications:
    ```json
    {json.dumps(specs_json, indent=2)}
    ```
    
    Architecture context:
    - Style: {architecture.get('architecture_style', 'Not specified')}
    - Key components: {', '.join([comp.get('name', 'Unknown') for comp in architecture.get('components', [])])}
    
    Please provide:
    1. Detailed implementation plan for each component
    2. Data structures and interfaces
    3. Algorithms and logic flows
    4. Integration points with other components
    5. Implementation considerations and guidelines
    
    Respond with JSON format containing:
    - components: Dictionary of component IDs to their implementation details
    - interfaces: Key interfaces needed
    - data_structures: Required data structures
    - algorithms: Key algorithms to implement
    - guidelines: Implementation guidelines
    """
    
    # Record the interaction
    interaction_id = f"translator_{uuid.uuid4().hex[:8]}"
    conversation_history.append({
        "id": interaction_id,
        "agent": "translator",
        "role": "system",
        "content": system_prompt
    })
    
    conversation_history.append({
        "id": interaction_id,
        "agent": "translator",
        "role": "user",
        "content": user_prompt
    })
    
    # Send request to OpenAI
    try:
        # the newest OpenAI model is "gpt-4o" which was released May 13, 2024.
        # do not change this unless explicitly requested by the user
        response = openai_client.chat.completions.create(
            model="gpt-4o",
            messages=[
                {"role": "system", "content": system_prompt},
                {"role": "user", "content": user_prompt}
            ],
            temperature=0.2,
            response_format={"type": "json_object"},
        )
        
        translation_result = json.loads(response.choices[0].message.content)
        
        # Record the response
        conversation_history.append({
            "id": interaction_id,
            "agent": "translator",
            "role": "assistant",
            "content": response.choices[0].message.content
        })
        
        # Return the translation results along with agent interactions
        return {
            'components': translation_result.get('components', {}),
            'interfaces': translation_result.get('interfaces', []),
            'data_structures': translation_result.get('data_structures', []),
            'algorithms': translation_result.get('algorithms', []),
            'guidelines': translation_result.get('guidelines', []),
            'agent_interactions': [
                {"id": interaction_id, "agent": "translator", "description": "Translated specifications to implementation details"}
            ]
        }
        
    except Exception as e:
        logger.error(f"Error in translator agent: {str(e)}")
        
        # Create fallback translation
        fallback_translation = {
            'components': {spec.entity_name: {"description": spec.purpose, "implementation_notes": "Basic implementation required"} for spec in step_specs},
            'interfaces': [],
            'data_structures': [],
            'algorithms': [],
            'guidelines': ["Implement basic functionality"],
            'agent_interactions': [
                {"id": interaction_id, "agent": "translator", "description": "Failed to translate specifications fully due to error", "error": str(e)}
            ]
        }
        
        # Record the error
        conversation_history.append({
            "id": interaction_id,
            "agent": "translator",
            "role": "error",
            "content": str(e)
        })
        
        return fallback_translation

def programmer_agent(
    step: ImplementationStep,
    step_specs: List[Specification],
    translation_result: Dict[str, Any],
    implementation_result: Dict[str, Any],
    conversation_history: List[Dict[str, Any]]
) -> Dict[str, Any]:
    """
    Use the programmer agent to generate code based on specifications and translation.
    
    Args:
        step: ImplementationStep object.
        step_specs: List of Specification objects for this step.
        translation_result: Results from the translator agent.
        implementation_result: Current implementation results.
        conversation_history: List to track agent interactions.
        
    Returns:
        Dictionary with programming results.
    """
    logger.info("Programmer agent: Generating code")
    
    # Initialize results
    programming_result = {
        'code_snippets': [],
        'agent_interactions': []
    }
    
    # Get file structure from implementation result
    file_structure = implementation_result['file_structure']
    
    # Map components to files
    component_file_mapping = {}
    for file_info in file_structure:
        for entity in file_info.get('entities', []):
            component_file_mapping[entity] = file_info['path']
    
    # Process each component in the translation result
    for component_id, component_details in translation_result.get('components', {}).items():
        # Find the file for this component
        file_path = component_file_mapping.get(component_id)
        
        if not file_path:
            # If no specific file found, use a default one
            file_path = f"{component_id.lower().replace(' ', '_')}.py"
        
        # Find matching specifications
        component_specs = [spec for spec in step_specs if spec.entity_name == component_id]
        
        if not component_specs:
            # If no specific specs found, use the first spec as a fallback
            component_specs = [step_specs[0]] if step_specs else []
        
        # Generate code for this component
        code_snippet = generate_component_code(
            component_id,
            component_details,
            component_specs,
            file_path,
            translation_result,
            implementation_result,
            conversation_history
        )
        
        programming_result['code_snippets'].append(code_snippet)
        programming_result['agent_interactions'].append({
            "id": code_snippet.get('interaction_id', 'unknown'),
            "agent": "programmer",
            "description": f"Generated code for {component_id}"
        })
    
    return programming_result

def generate_component_code(
    component_id: str,
    component_details: Dict[str, Any],
    component_specs: List[Specification],
    file_path: str,
    translation_result: Dict[str, Any],
    implementation_result: Dict[str, Any],
    conversation_history: List[Dict[str, Any]]
) -> Dict[str, Any]:
    """
    Generate code for a specific component.
    
    Args:
        component_id: ID of the component.
        component_details: Details of the component from translation.
        component_specs: List of specifications for this component.
        file_path: File path for the component code.
        translation_result: Results from the translator agent.
        implementation_result: Current implementation results.
        conversation_history: List to track agent interactions.
        
    Returns:
        Dictionary with code snippet details.
    """
    # Create system prompt for the programmer agent
    system_prompt = f"""
    You are an expert software programmer. Your task is to generate high-quality code for a specific component.
    
    Your responsibilities:
    1. Implement the component according to specifications and translation details
    2. Write clean, efficient, and maintainable code
    3. Follow best practices and design patterns
    4. Ensure proper error handling and validation
    5. Document the code appropriately
    
    You should generate complete, production-ready code that could be directly added to a file.
    """
    
    # Prepare specifications for the prompt
    specs_json = []
    for spec in component_specs:
        spec_dict = {
            "entity_name": spec.entity_name,
            "entity_type": spec.entity_type,
            "purpose": spec.purpose,
            "inputs": spec.inputs,
            "outputs": spec.outputs,
            "constraints": spec.constraints,
            "dependencies": spec.dependencies,
            "behavior": spec.behavior[:500] if spec.behavior else None  # Limit length
        }
        specs_json.append(spec_dict)
    
    # Create user prompt with component details
    user_prompt = f"""
    Generate code for the following component:
    
    Component: {component_id}
    File path: {file_path}
    
    Component details:
    ```json
    {json.dumps(component_details, indent=2)}
    ```
    
    Component specifications:
    ```json
    {json.dumps(specs_json, indent=2)}
    ```
    
    Implementation guidelines:
    ```json
    {json.dumps(translation_result.get('guidelines', []), indent=2)}
    ```
    
    Generate the complete code for this component that should be placed in {file_path}.
    Do not include any explanations, just the code itself.
    Ensure the code follows best practices and includes proper error handling.
    The code should be complete and ready to use without modifications.
    """
    
    # Record the interaction
    interaction_id = f"programmer_{uuid.uuid4().hex[:8]}"
    conversation_history.append({
        "id": interaction_id,
        "agent": "programmer",
        "role": "system",
        "content": system_prompt
    })
    
    conversation_history.append({
        "id": interaction_id,
        "agent": "programmer",
        "role": "user",
        "content": user_prompt
    })
    
    # Send request to OpenAI
    try:
        # the newest OpenAI model is "gpt-4o" which was released May 13, 2024.
        # do not change this unless explicitly requested by the user
        response = openai_client.chat.completions.create(
            model="gpt-4o",
            messages=[
                {"role": "system", "content": system_prompt},
                {"role": "user", "content": user_prompt}
            ],
            temperature=0.2,
        )
        
        code_content = response.choices[0].message.content
        
        # Remove markdown code block formatting if present
        code_content = re.sub(r'^```\w*\n', '', code_content, flags=re.MULTILINE)
        code_content = re.sub(r'\n```$', '', code_content, flags=re.MULTILINE)
        
        # Record the response
        conversation_history.append({
            "id": interaction_id,
            "agent": "programmer",
            "role": "assistant",
            "content": response.choices[0].message.content
        })
        
        # Create code snippet result
        code_snippet = {
            'component_id': component_id,
            'file_path': file_path,
            'code': code_content,
            'interaction_id': interaction_id
        }
        
        return code_snippet
        
    except Exception as e:
        logger.error(f"Error in programmer agent for component {component_id}: {str(e)}")
        
        # Create fallback code snippet
        fallback_code = f"""
# TODO: Implement {component_id}
# Error occurred during code generation: {str(e)}

class {component_id}:
    def __init__(self):
        self.name = "{component_id}"
        
    def placeholder_method(self):
        # Placeholder implementation
        return "Not implemented yet"
"""
        
        # Record the error
        conversation_history.append({
            "id": interaction_id,
            "agent": "programmer",
            "role": "error",
            "content": str(e)
        })
        
        # Create code snippet result
        code_snippet = {
            'component_id': component_id,
            'file_path': file_path,
            'code': fallback_code,
            'interaction_id': interaction_id,
            'error': str(e)
        }
        
        return code_snippet

def reviewer_agent(
    step: ImplementationStep,
    step_specs: List[Specification],
    programming_result: Dict[str, Any],
    implementation_result: Dict[str, Any],
    conversation_history: List[Dict[str, Any]]
) -> Dict[str, Any]:
    """
    Use the reviewer agent to check the generated code.
    
    Args:
        step: ImplementationStep object.
        step_specs: List of Specification objects for this step.
        programming_result: Results from the programmer agent.
        implementation_result: Current implementation results.
        conversation_history: List to track agent interactions.
        
    Returns:
        Dictionary with review results.
    """
    logger.info("Reviewer agent: Checking code against specifications and best practices")
    
    # Initialize review results
    review_result = {
        'issues': [],
        'suggestions': [],
        'agent_interactions': []
    }
    
    # Process each code snippet
    for snippet in programming_result['code_snippets']:
        component_id = snippet['component_id']
        file_path = snippet['file_path']
        code = snippet['code']
        
        # Find matching specifications
        component_specs = [spec for spec in step_specs if spec.entity_name == component_id]
        
        if not component_specs:
            # If no specific specs found, use the first spec as a fallback
            component_specs = [step_specs[0]] if step_specs else []
        
        # Review the code
        snippet_review = review_code_snippet(
            component_id,
            component_specs,
            code,
            file_path,
            step.validation_criteria,
            conversation_history
        )
        
        # Add review results
        review_result['issues'].extend(snippet_review['issues'])
        review_result['suggestions'].extend(snippet_review['suggestions'])
        review_result['agent_interactions'].append({
            "id": snippet_review.get('interaction_id', 'unknown'),
            "agent": "reviewer",
            "description": f"Reviewed code for {component_id}"
        })
    
    return review_result

def review_code_snippet(
    component_id: str,
    component_specs: List[Specification],
    code: str,
    file_path: str,
    validation_criteria: List[str],
    conversation_history: List[Dict[str, Any]]
) -> Dict[str, Any]:
    """
    Review a code snippet for issues and suggestions.
    
    Args:
        component_id: ID of the component.
        component_specs: List of specifications for this component.
        code: Code snippet to review.
        file_path: File path for the component code.
        validation_criteria: Validation criteria from the implementation step.
        conversation_history: List to track agent interactions.
        
    Returns:
        Dictionary with review results.
    """
    # Create system prompt for the reviewer agent
    system_prompt = f"""
    You are an expert code reviewer. Your task is to review code for correctness, adherence to specifications,
    and best practices.
    
    Your responsibilities:
    1. Check if the code implements all required functionality
    2. Verify adherence to specifications
    3. Identify potential bugs or issues
    4. Evaluate code quality and best practices
    5. Suggest improvements
    
    Be thorough but fair in your assessment.
    """
    
    # Prepare specifications for the prompt
    specs_json = []
    for spec in component_specs:
        spec_dict = {
            "entity_name": spec.entity_name,
            "entity_type": spec.entity_type,
            "purpose": spec.purpose,
            "inputs": spec.inputs,
            "outputs": spec.outputs,
            "constraints": spec.constraints,
            "dependencies": spec.dependencies,
            "behavior": spec.behavior[:500] if spec.behavior else None  # Limit length
        }
        specs_json.append(spec_dict)
    
    # Create user prompt with code and specifications
    user_prompt = f"""
    Review the following code for the component {component_id} in file {file_path}:
    
    ```
    {code}
    ```
    
    Component specifications:
    ```json
    {json.dumps(specs_json, indent=2)}
    ```
    
    Validation criteria:
    {chr(10).join(['- ' + criterion for criterion in validation_criteria])}
    
    Please review the code and identify:
    1. Any issues or bugs in the implementation
    2. Missing functionality based on specifications
    3. Violations of best practices
    4. Potential improvements
    
    Respond with JSON format containing:
    - issues: List of issues found (critical problems that must be fixed)
    - suggestions: List of suggestions for improvement (non-critical)
    - overall_assessment: Brief overall assessment
    """
    
    # Record the interaction
    interaction_id = f"reviewer_{uuid.uuid4().hex[:8]}"
    conversation_history.append({
        "id": interaction_id,
        "agent": "reviewer",
        "role": "system",
        "content": system_prompt
    })
    
    conversation_history.append({
        "id": interaction_id,
        "agent": "reviewer",
        "role": "user",
        "content": user_prompt
    })
    
    # Send request to OpenAI
    try:
        # the newest OpenAI model is "gpt-4o" which was released May 13, 2024.
        # do not change this unless explicitly requested by the user
        response = openai_client.chat.completions.create(
            model="gpt-4o",
            messages=[
                {"role": "system", "content": system_prompt},
                {"role": "user", "content": user_prompt}
            ],
            temperature=0.2,
            response_format={"type": "json_object"},
        )
        
        review_result = json.loads(response.choices[0].message.content)
        
        # Record the response
        conversation_history.append({
            "id": interaction_id,
            "agent": "reviewer",
            "role": "assistant",
            "content": response.choices[0].message.content
        })
        
        # Format issues and suggestions with component ID prefix
        issues = []
        suggestions = []
        
        for issue in review_result.get('issues', []):
            issues.append({
                'component_id': component_id,
                'file_path': file_path,
                'description': issue
            })
        
        for suggestion in review_result.get('suggestions', []):
            suggestions.append({
                'component_id': component_id,
                'file_path': file_path,
                'description': suggestion
            })
        
        # Return the review results
        return {
            'issues': issues,
            'suggestions': suggestions,
            'overall_assessment': review_result.get('overall_assessment', ''),
            'interaction_id': interaction_id
        }
        
    except Exception as e:
        logger.error(f"Error in reviewer agent for component {component_id}: {str(e)}")
        
        # Record the error
        conversation_history.append({
            "id": interaction_id,
            "agent": "reviewer",
            "role": "error",
            "content": str(e)
        })
        
        # Return minimal review results
        return {
            'issues': [{
                'component_id': component_id,
                'file_path': file_path,
                'description': f"Error reviewing code: {str(e)}"
            }],
            'suggestions': [],
            'overall_assessment': "Review failed due to error",
            'interaction_id': interaction_id,
            'error': str(e)
        }

def refiner_agent(
    step: ImplementationStep,
    step_specs: List[Specification],
    programming_result: Dict[str, Any],
    review_result: Dict[str, Any],
    implementation_result: Dict[str, Any],
    conversation_history: List[Dict[str, Any]]
) -> Dict[str, Any]:
    """
    Use the refiner agent to improve code based on review feedback.
    
    Args:
        step: ImplementationStep object.
        step_specs: List of Specification objects for this step.
        programming_result: Results from the programmer agent.
        review_result: Results from the reviewer agent.
        implementation_result: Current implementation results.
        conversation_history: List to track agent interactions.
        
    Returns:
        Dictionary with refinement results.
    """
    logger.info("Refiner agent: Improving code based on review feedback")
    
    # Initialize refinement results
    refinement_result = {
        'code_snippets': [],
        'agent_interactions': []
    }
    
    # Process each code snippet
    for snippet in programming_result['code_snippets']:
        component_id = snippet['component_id']
        file_path = snippet['file_path']
        code = snippet['code']
        
        # Find matching specifications
        component_specs = [spec for spec in step_specs if spec.entity_name == component_id]
        
        if not component_specs:
            # If no specific specs found, use the first spec as a fallback
            component_specs = [step_specs[0]] if step_specs else []
        
        # Find issues and suggestions for this component
        component_issues = [issue for issue in review_result['issues'] 
                           if issue['component_id'] == component_id]
        
        component_suggestions = [suggestion for suggestion in review_result['suggestions'] 
                                if suggestion['component_id'] == component_id]
        
        # Refine the code
        refined_snippet = refine_code_snippet(
            component_id,
            component_specs,
            code,
            file_path,
            component_issues,
            component_suggestions,
            conversation_history
        )
        
        refinement_result['code_snippets'].append(refined_snippet)
        refinement_result['agent_interactions'].append({
            "id": refined_snippet.get('interaction_id', 'unknown'),
            "agent": "refiner",
            "description": f"Refined code for {component_id}"
        })
    
    return refinement_result

def refine_code_snippet(
    component_id: str,
    component_specs: List[Specification],
    code: str,
    file_path: str,
    issues: List[Dict[str, Any]],
    suggestions: List[Dict[str, Any]],
    conversation_history: List[Dict[str, Any]]
) -> Dict[str, Any]:
    """
    Refine a code snippet based on review feedback.
    
    Args:
        component_id: ID of the component.
        component_specs: List of specifications for this component.
        code: Original code snippet.
        file_path: File path for the component code.
        issues: List of issues identified in the review.
        suggestions: List of suggestions from the review.
        conversation_history: List to track agent interactions.
        
    Returns:
        Dictionary with refined code snippet.
    """
    # If no issues or suggestions, return the original code
    if not issues and not suggestions:
        return {
            'component_id': component_id,
            'file_path': file_path,
            'code': code
        }
    
    # Create system prompt for the refiner agent
    system_prompt = f"""
    You are an expert code refiner. Your task is to improve code based on review feedback.
    
    Your responsibilities:
    1. Fix all identified issues
    2. Implement suggested improvements
    3. Ensure the code follows best practices
    4. Maintain or improve code readability
    5. Ensure the code meets all specifications
    
    You should provide the complete, revised code that addresses all issues and incorporates
    the suggestions as appropriate.
    """
    
    # Prepare specifications for the prompt
    specs_json = []
    for spec in component_specs:
        spec_dict = {
            "entity_name": spec.entity_name,
            "entity_type": spec.entity_type,
            "purpose": spec.purpose,
            "inputs": spec.inputs,
            "outputs": spec.outputs,
            "constraints": spec.constraints,
            "dependencies": spec.dependencies,
            "behavior": spec.behavior[:500] if spec.behavior else None  # Limit length
        }
        specs_json.append(spec_dict)
    
    # Format issues and suggestions
    issues_text = '\n'.join([f"- {issue['description']}" for issue in issues])
    suggestions_text = '\n'.join([f"- {suggestion['description']}" for suggestion in suggestions])
    
    # Create user prompt with code, issues, and suggestions
    user_prompt = f"""
    Refine the following code for the component {component_id} in file {file_path}:
    
    ```
    {code}
    ```
    
    Issues to fix:
    {issues_text if issues else "No critical issues identified."}
    
    Suggestions for improvement:
    {suggestions_text if suggestions else "No improvement suggestions."}
    
    Component specifications:
    ```json
    {json.dumps(specs_json, indent=2)}
    ```
    
    Please provide the complete refined code that addresses all issues and incorporates
    the suggestions as appropriate. Do not include any explanations, just the code itself.
    """
    
    # Record the interaction
    interaction_id = f"refiner_{uuid.uuid4().hex[:8]}"
    conversation_history.append({
        "id": interaction_id,
        "agent": "refiner",
        "role": "system",
        "content": system_prompt
    })
    
    conversation_history.append({
        "id": interaction_id,
        "agent": "refiner",
        "role": "user",
        "content": user_prompt
    })
    
    # Send request to OpenAI
    try:
        # the newest OpenAI model is "gpt-4o" which was released May 13, 2024.
        # do not change this unless explicitly requested by the user
        response = openai_client.chat.completions.create(
            model="gpt-4o",
            messages=[
                {"role": "system", "content": system_prompt},
                {"role": "user", "content": user_prompt}
            ],
            temperature=0.2,
        )
        
        refined_code = response.choices[0].message.content
        
        # Remove markdown code block formatting if present
        refined_code = re.sub(r'^```\w*\n', '', refined_code, flags=re.MULTILINE)
        refined_code = re.sub(r'\n```$', '', refined_code, flags=re.MULTILINE)
        
        # Record the response
        conversation_history.append({
            "id": interaction_id,
            "agent": "refiner",
            "role": "assistant",
            "content": response.choices[0].message.content
        })
        
        # Create refined code snippet result
        refined_snippet = {
            'component_id': component_id,
            'file_path': file_path,
            'code': refined_code,
            'interaction_id': interaction_id
        }
        
        return refined_snippet
        
    except Exception as e:
        logger.error(f"Error in refiner agent for component {component_id}: {str(e)}")
        
        # Record the error
        conversation_history.append({
            "id": interaction_id,
            "agent": "refiner",
            "role": "error",
            "content": str(e)
        })
        
        # Return the original code if refinement fails
        return {
            'component_id': component_id,
            'file_path': file_path,
            'code': code,
            'interaction_id': interaction_id,
            'error': str(e)
        }

def generate_execution_details(
    implementation_result: Dict[str, Any],
    conversation_history: List[Dict[str, Any]]
) -> Dict[str, Any]:
    """
    Generate execution details for the implemented code.
    
    Args:
        implementation_result: Current implementation results.
        conversation_history: List of agent interactions.
        
    Returns:
        Dictionary with execution details.
    """
    logger.info("Generating execution details for implemented code")
    
    # Create system prompt
    system_prompt = """
    You are an expert in software execution and deployment. Your task is to provide
    clear instructions for running and deploying the implemented code.
    
    Your responsibilities:
    1. Identify entry points and execution order
    2. Provide clear step-by-step execution instructions
    3. Specify any environment setup required
    4. Detail deployment considerations
    5. Highlight any configuration needed
    """
    
    # Prepare file structure for prompt
    file_structure = implementation_result['file_structure']
    code_snippets = implementation_result['implementation_details']['code_snippets']
    
    # Find potential entry points
    entry_points = []
    for snippet in code_snippets:
        # Look for common entry point patterns
        if 'if __name__ == "__main__"' in snippet['code'] or 'app.run(' in snippet['code']:
            entry_points.append(snippet['file_path'])
    
    # Create user prompt
    user_prompt = f"""
    Provide execution instructions for the implemented codebase with the following structure:
    
    File structure:
    {chr(10).join(['- ' + file_info['path'] for file_info in file_structure])}
    
    Potential entry points:
    {chr(10).join(['- ' + entry_point for entry_point in entry_points]) if entry_points else "No clear entry points identified."}
    
    Please provide:
    1. Step-by-step execution instructions
    2. Environment setup requirements
    3. Deployment considerations
    4. Configuration details
    
    Respond with JSON format containing:
    - instructions: Detailed execution instructions
    - environment_setup: Environment setup steps
    - deployment: Deployment guidelines
    - configuration: Configuration details
    - entry_points: List of entry point files and how to run them
    """
    
    # Record the interaction
    interaction_id = f"execution_{uuid.uuid4().hex[:8]}"
    conversation_history.append({
        "id": interaction_id,
        "agent": "execution",
        "role": "system",
        "content": system_prompt
    })
    
    conversation_history.append({
        "id": interaction_id,
        "agent": "execution",
        "role": "user",
        "content": user_prompt
    })
    
    # Send request to OpenAI
    try:
        # the newest OpenAI model is "gpt-4o" which was released May 13, 2024.
        # do not change this unless explicitly requested by the user
        response = openai_client.chat.completions.create(
            model="gpt-4o",
            messages=[
                {"role": "system", "content": system_prompt},
                {"role": "user", "content": user_prompt}
            ],
            temperature=0.2,
            response_format={"type": "json_object"},
        )
        
        execution_details = json.loads(response.choices[0].message.content)
        
        # Record the response
        conversation_history.append({
            "id": interaction_id,
            "agent": "execution",
            "role": "assistant",
            "content": response.choices[0].message.content
        })
        
        # Add interaction ID to execution details
        execution_details['interaction_id'] = interaction_id
        
        return execution_details
        
    except Exception as e:
        logger.error(f"Error generating execution details: {str(e)}")
        
        # Record the error
        conversation_history.append({
            "id": interaction_id,
            "agent": "execution",
            "role": "error",
            "content": str(e)
        })
        
        # Create fallback execution details
        fallback_details = {
            'instructions': "Basic execution steps:\n1. Install required dependencies\n2. Run the main entry point",
            'environment_setup': "Ensure all dependencies are installed.",
            'deployment': "Deploy according to standard practices for this type of application.",
            'configuration': "No specific configuration details available.",
            'entry_points': entry_points or ["No clear entry points identified."],
            'interaction_id': interaction_id,
            'error': str(e)
        }
        
        return fallback_details
